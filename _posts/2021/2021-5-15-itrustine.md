---
layout: post
title: Réflexion - Pour la fin des rustines informatiques
category: geek, reflexion
tags: développement, informatique, programmation, web, internet
---

**Le monde de l'informatique a évolué tant qu'aujourd'hui, il est largement constitué de rustines appelés surcouches, correctifs, etc... Elles sont à tous niveaux entre les dépendances de plus en plus nombreuses pour des environnements similaires, dans les OS, entre les langages, les sous-langages, entre les protocoles et leurs surcouches de protocoles. Cela devient un grand imbroglio...**

...qui fait que l'on recrée par dessus tout ça des packages pour tout mettre dedans...des packages gérés avec encore d'autres gestionnaires, qui ne font pourtant même pas le café pendant que l'on attend la mise à jour. STOOOOOPPPPPPP!

Je sais, on va me répondre que le progrès fait que l'on rajoute de nouvelles fonctions, que l'on crée de nouvelles choses. Mais franchement, quand le langage C continue d'exister depuis des décennies, a-t-on besoin de voir une profusion de langage devenir à la mode et disparaître au fil des ans ? C'est comme la mode vestimentaire, on réinvente cycliquement la roue, en faisant croire que c'est nouveau. On reste quand même très proches dans les syntaxes et les principes, au point que je ne suis pas très dépaysé en lisant certains codes. Mais qu'est-ce que l'on maîtrise réellement dans le code en rajoutant dépendances et surcouches? De moins en moins puisque à chaque fois que l'on empile des choses, on crée de potentielles failles. J'ai déjà parlé de la facilité d'avoir des outils pour développer tout intégrés et qui gèrent tout cela comme ils peuvent mais ils font croire à l'invulnérabilité et en même temps enferment l'utilisateur dans un schéma.

Cela m'a sauté aux yeux **quand j'ai travaillé sur le site** ici présent, quand j'ai essayé diverses solutions de site statique, ce qui est plus basique pourtant. A chaque fois, j'avais un langage à installer, puis le générateur de site qui demandait en sus quelques autres dépendances, puis lorsque je voulais quelques fonctions en plus, que je testais un template, ça faisait appel à d'autres choses qui se géraient parfois par un petite gestionnaire spécifique au langage. Si bien que j'ai viré tout ce qui était automatisé dans mon "template" pour le refaire par moi-même. Au moins, si ça ne fonctionne plus, je m'en prendrais à moi même et pas à un quelconque développeur qui a rajouté 10 lignes dans son truc. Reste le cas de l’interpréteur Markdown (oui, il y en a plusieurs aussi pour un même environnement) par exemple que je ne peux pas éviter alors je vais vers le standard originel, c'est mieux. Là aussi, j'ai un peu de mal à comprendre le besoin de sortir de ça, quand il suffirait de rajouter ce qui manque dans une version du même interpréteur. Je me doute hélas de la réponse qu'on me donnerait...

Je ne voudrais pourtant pas retomber dans le vieux débat entre **le niveaux des langages informatiques**. Il est loin le temps des langages que l'on disait de "bas niveau" où l'on attaque directement la machine. Mais à force j'ai l'impression qu'après les langages de "haut niveau", on s'est amusé à créer une strate de plus avec des bibliothèques qui donnent accès à des fonctionnalités de manière unifiées. La hardware a aussi des pilotes qui vont se conformer à tout cela. Il faut dire aussi que le hardware est si divers qu'il est difficile de s'y retrouver pour la programmation. Il n'y a qu'à voir le nombre d'incompatibilités sur Android avec même des jeux premium qui ne tournent pas sur les modèles vieux de un an d'un grand constructeur coréen. Rajoutons aussi le 32bits, le 64bits dans l'équation et il y a de quoi avoir des migraines dans le choix qui s'offre. Il y a plus de 200 langages de programmation recensés en 2010 selon wikipedia...Vous vous souvenez de LOGO, COBOL, FORTRAN ? qui ont pourtant leur intérêt...On rigolera de Scratch dans quelques années.

Des bibliothèques deviennent hégémoniques sur certaines plateformes... Microsoft comme tout ce qui est .net, après avoir connu le Directx et tous les programmes faisant appel à du VisualBasic. Qui peut passer à coté de GTK aujourd'hui dans sa dernière version dans l'environnement Linux...Il faut évidemment distinguer **les bibliothèques d'outils** des langages, les uns faisant appel aux autres. Ce qui me pose un problème, c'est que si on décide de ne pas être en Gnome, XFCE, on va aller plutôt sur du QT. Je vous défie de vous passer de l'une ou de l'autre aujourd'hui pour alléger votre système. L'avantage de ces bibliothèques est qu'elles sont multi-plate-formes, à la différence de celles de Microsoft, il y a quelques années. Oui, ils s'attaquent au multi-plate-forme aussi. Mais si on facilite la tâche au départ, a-t-on vraiment besoin de sortir l'artillerie lourde pour un petit programme léger ? Ces bibliothèques grossissent considérablement. Si on reste dans le domaine du raisonnable sur Linux, on est à plus de 100Mo pour les .net framework dernières version. Tu t'imagines faire une appli de 15mo si tu as besoin d'installer 130Mo de bibliothèque? Il y a vraiment une réflexion à avoir.

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c0/Painting%3B_oil_on_canvas_-_Interior_of_a_Tailor%27s_Shop_-_Google_Art_Project.jpg/640px-Painting%3B_oil_on_canvas_-_Interior_of_a_Tailor%27s_Shop_-_Google_Art_Project.jpg)

*Intérieur d'une atelier de tailleur - Anonyme 1780*

Outre le ratio taille de programme / taille des dépendances, j'aimerai **que les dépendances restent réduites** à 2 voir trois maximum. Car on peut cumuler avec des appels à des petits outils annexes, des API. Plus facile à dire qu'à faire. Surtout que je vois cela du côté utilisateur. A l'installation, il y a aussi plusieurs écoles. Avec des gestionnaires genre synaptics, c'était sympa, tu voyais ce que tu avais comme dépendance proposée pour ton programme et ce que ça impactait sur ta machine. On ne faisait pas forcément gaffe à ça dans les commandes APT-GET... Avec des packages en snap, appimage et compagnie, bonjour le foutoir. Pas de chance, avec la dernière Ubuntu on cumule tout au point d'avoir des versions dans l'un ou l'autre sur un même système. J'en viendrais presque à regretter les installeurs Windows avec la gestion des DLL. Si au moins je comprenais l'intérêt qu'il y a eu à ne pas savoir faire évoluer un ou deux standard et à l'imposer sur une branche Linux! L'informaticien programmeur aime oublier qu'au bout, il y a un utilisateur.

Je vais faire **un parallèle avec la musique** où là aussi de nombreux outils permettent d'avoir un résultat potable. J'en ai été utilisateur comme j'ai été utilisateur de séquenceurs avec des claviers maîtres pour jouer véritablement avec des tables d'ondes. J'ai aussi utilisé du Tracker à l'époque de la Demoscene et c'était franchement ardu à comprendre. Maintenant, on arrive à faire un truc écoutable avec des intelligences qui gèrent le BPM des samples parfois, même s'il y a des règles dont on ne peut pas se départir. Mais ... Le son est quand même un peu pourrave là plupart du temps, à moins d'aller dans un truc plus pro, avec des samples de qualité. Ça va entre potes dans une soirée un peu arrosée mais au delà, il faut se sortir un peu les tripes, le carnet de chèque pour changer de division. Je sais que malheureusement avec le règne de la musique en Streaming, du MP3, notre capacité à déceler un bon son diminue... Comme l’élasticité de mes tympans avec l'âge. 

Les autres rustines informatiques, ce sont **ces patchs** qui n'en finissent plus. La sortie de Cyberpunk 2077 m'a bien fait rire. Ils ont voulu absolument sortir leur bouse avant les fêtes tout en sachant que le produit était bogué. "Pas grave, on patchera" a du dire un grand ponte qui sait tout. A-t-on oublié le légendaire Driver 3 qui sortit complètement bâclé. Sauf qu'à l'époque sur PS2, il n'y avait pas la possibilité de corriger le tire comme maintenant grâce aux mises à jour en réseau. Cette facilité pour corriger ce que l'on n'a pas pu forcément voir dans les tests est devenu un piège car on bâcle alors toute la phase test. Je l'ai vécu aussi dans mon travail où j'ai vécu deux mises en place de logiciels à 15 ans d'écart et j'ai vu le manque de sérieux de la phase de recette et de test dernièrement. Malheureusement, la mise en place de patches n'est pas toujours aussi facile dans une entreprise que sur une console de salon. 

Évidemment, il y aura toujours besoin de mises à jour, de correctifs. Mais à trop vouloir en faire, on oublie les réflexes élémentaires du développement qui demandent **du temps, de l'organisation, ... du savoir faire.** Dans un monde habitué à aller plus vite, par son aspect hyper-concurrentiel, on en vient à perdre de vue un autre aspect essentiel : La satisfaction client. Elle a pour critère justement la fiabilité, la facilité d'utilisation , la robustesse dans le temps, tous ces éléments peu pris en compte dans ce monde de l'informatique qui veut changer toujours plus vite. Pour un utilisateur chevronné, que fait-on réellement de plus entre le Word 6 et le dernier LibreOffice, entre Excel 7 et la dernière version Office 365, en dehors de faire des documents partagés online? Et encore, ces produits ont des mises à jour bien plus rares que d'autres produits informatiques. Le comble du ridicule a été atteint avec les versions des navigateurs et leur numérotation instituée par Google pour Chrome et suivie servilement par ses concurrents. Ah si au moins on se concentrait sur l'essentiel, la sécurité, plutôt que sur la dernière lubie réinventant la roue d'un type qui veut se faire mousser.

J'ai vu récemment Frédéric B grogner sur ce que fait Canonical, être plus indulgent avec Gnome, rire comme moi sur Cyberpunk. L'informatique qui aurait du s'orienter vers la simplification et la performance est devenue paradoxalement un truc **de plus en plus complexe** car l'humain l'a rendu ainsi en se refusant à faire des choix. J'ai pour coutume de dire que tout est politique et là encore c'est purement politique. Ne pas vouloir faire comme le concurrent, ne pas vouloir partager, ne pas vouloir collaborer, ne pas vouloir reprendre ce qui existait, c'est politique. Et comme l'humain est un animal qui aime semer le chaos, comment pouvait-il en être autrement avec l'informatique et son développement ? Je vous laisse méditer sur le fait qu'un ordinateur d'aujourd'hui qui a plusieurs coeurs à plusieurs Gigahertz, des mémoires et disques SSD met presque plus de temps pour arriver à l'ouverture d'un traitement de texte que je ne pouvais le faire dans les années 80. On me répondra qu'on fait plus de choses aujourd'hui...? Mouais. Se penchera-t-on un jour sur les besoins les plus basiques dès la conception. L'après smartphone sera peut-être là.

Je vous laisse imaginer le fonctionnement de l'informatique actuelle dans d'autres secteurs d'activité. Il y a des dystopies qui l'ont déjà fait...Je vous laisse imaginer acheter du pain  qui n'a pas été fini de cuire. Ou alors d'avoir droit de le manger à 10% et ensuite de devoir repayer si vous décider d'en manger un peu plus tard. Ou bien d'acheter de force 30 croissants, et éclairs au nutella en même temps que la baguette, même si on ne veut faire qu'un sandwich. Je vous laisse imaginer un jean qui aurait du fil qui ne tient pas le premier lavage. Ou bien encore qui ne pourrait s'enlever que si on s'abonne à un service. Ou dont l'ouverture des boutons ne serait possible qu'après une formation d'une semaine à un autre outil. Et bien ces petits cauchemars, c'est ce que nous promet le merveilleux monde de l'informatique d'aujourd'hui ou de demain. Autant vous dire que ça ne passera pas par moi et que je laisserai ceux qui ont choisi ça se démerder joyeusement avec leurs problèmes. Mais il reste aussi possible de faire soi-même son pain, de réparer son jean ou carrément de faire soi-même ses vêtements, si vous voyez ce que je veux dire. Juste que j'aurais aimé un entre-deux qui disparaît peu à peu.

Bande-son : [In This Moment - The In Between ![video](/images/youtube.png)](https://www.youtube.com/watch?v=pjOtKC_GZ9o){:target="_blank"}

#### Commentaires

**Popolon sur Mastodon**

>  Je suis bien d'accord, il faudrait sortir des programmes sans bugs et complètements complets des le premier claquement de doigt ^ ^. Pour l'analogie avec la musique : Non, il y a des logiciels de musiques libres professionnels gratuits et aux sons d'une qualité irréprochable. À propos de patchs, l'utilisation de synthétiseurs modulaire, que ce soit matériel avec des baies de patchs, ou logiciel avec des tonnes de plugins VST/LV2, etc...) ça en fait aussi des choses complexes et c'est ce que veulent les musiciens pour avoir toute une panoplie d'instruments spécialisés. Le cas contraire serait par exemple limiter un orchestre philharmonique à des seuls violons, ça se fait mais c'est moins riche qu'un orchestre hétérogène avec toutes ses différences et les qualités de ces différences.

> L'avantage d'utiliser plusieurs bibliothèques spécialisées en va de même, ne pas refaire 150 fois le même travail, sauf si on ne peut intégrer ses besoin à l'existant, mais préférer proposer un patchs adaptatif aux auteurs de la bibliothèque. La tendance du monde de Rust est de tout dupliquer en statique, ça à tout de même pas mal d'inconvénient:
> * ça prend beaucoup de place (disque, mémoire) dans un monde fini avec des ressources fini. Plus de place sur disque veut aussi dire, plus de temps de chargement en mémoire, et de plus de chance de sortir des caches.
> * Quand il y a un correctif sur une bibliothèque (comme elles sont codées par des humains). Au lieu de juste recompiler la biblio, il fait recompiler tous les programmes liés en statiques. Non seulement ça va prendre beaucoup plus de ressources (CPU pour tout recompiler+ stockage nécessaire sur l’ordinateur qui compile), mais en plus ça va encore démultiplier la taille des programmes sur disque, transfert vers chez les utilisateurs de la distro, restockage chez eux). Il faudra de plus bien penser ou bien avoir automatisé la recompilation automatique de tous les logiciels utilisant cette bibliothèque.... Un travail monstrueux au global, lorsque la compilation de la petite bibliothèque aurait été suffisante.

**Iceman**

> Ah si la perfection existait :D C'est justement parce qu'on sous-estime le temps de test et aussi d'optimisation que l'on a aujourd'hui des programmes avec des bugs majeurs qui sortent. J'en ai quelques exemples en mémoire dans mon boulot, autant que de bons exemples inverses, heureusement. 

> C'est vrai que pour la musique j'aurais du préciser de quel type d'outils je parlais car il y a aussi de très bons produits libres du niveau pro. Je pensais plus à ceux que l'on trouve plutôt sur mobile, tablette et qui automatisent la prod pour "faire du son" genre beatmakers.

> Et bien sur que la bibliothèque simplifie le travail mais quelque part on en perd le savoir-faire et donc comme tu le dis, on prend le risque lors d'une modif de bibliothèque d'avoir beaucoup plus de travail et de lourdeur. C'est aussi un choix que l'on paye par des lenteurs à l'utilisation quand d'autres optimisent le code pour la performance, étape tout simplement zappée dans le développement puisque l'on se dit "le hardware à venir compensera".



